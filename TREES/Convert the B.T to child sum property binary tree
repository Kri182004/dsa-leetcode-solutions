class solution{
void chnageTrees(BinaryTreeNode<int> *root){
if(root==nullptr)return;
int child=0;
if(root->left){
child+=root->left->data;
}
if(root->right){
child+=root->right->data;
}
if(child<=root->data){
if(root->left) root->left->data=root->data;
if(root->right) root->right->data=root->data;
}
else{
if(child>=root->data) root->data=child;
}
chnageTree(root->left);
changeTree(root->right;
int tot=0;
if(root->left)tot+=root->left->data;
if(root->right)tot+=root->right->data;
if(root->left|| root->right) root->data=tot;
}
}                                                                             
                                                                       
         

                   50
                 /    \
               7        2 
             /  \      /    \
           3     5    1      30



iss exmaple me agar ham phle parentsko he dekh (level3=>3+5->8(parent 7)chnage to ->8 (done)
then 1+30->31 now ab chnage the parent->from 2->31
now level two has (8 and 31) which correct since thir child are summing up np
but when on level 2(8 and 31->they aren't giving 50 they are giving 39) so we are not following the child sum property ie. 50(w cannot chnage the childs now otherwise it wil mess up)

so you better ad values to other  levels down then use recursion from bottom to up to sum up to actual one
complexity=0(N)
0(n)


so using the above algo===>we reduce it do===
==========================================
            200
          /     \
        100      100
       /   \     /   \
      50   50   50   50



                                                          
